(use 'mikera.vectorz.core)
(vec4)
(vec4 1 2 3 4)
(def a (java.util.ArrayList. []))
(.add a 3)
(a)
(toString. a)
(.toString a)
(.add a 6)
(.add a 7 9)
(.add a 0 9)
(.toString a)
(def m1 [[1 2 3 4]])
(def m1 [[1 2 3 4]
[0 0 10 0]
[3 0 5 6]])
(m1)
m1
(import [mikera.matrixx.decompose QR])
(import [mikera.matrixx AMatrix])
(def m2 m1)
m2
(+ m2 m1)
(def M1 (matrix m1))
(def M1 (mikera.matrixx.Matrix. m1))
(def M1 (new mikera.matrixx.Matrix m1))
(def M1 (mikera.matrixx.Matrix/create m1 ))
(def M1 (mikera.matrixx.Matrix/create (to-array m1) ))
(def M1 (mikera.matrixx.Matrix/create (clojure.core/to-array m1) ))
M1
(def M2 M1)
M2
(def M3 (mikera.matrixx.Matrix/create [[1 2 3]
  [4 5 6]]))
(def M3 (mikera.matrixx.Matrix/create {{1, 2, 3}, {4, 5, 6}}))
(use clojure.core.matrix.linear)
(use clojure.core.matrix.protocols)
(use clojure.core.matrix)
(use mikera.vectorz.matrix_api)
(use mikera.vectorz.core)
(in-ns mikera.vectorz.core)
(in-ns mikera.vectorz)
(all-ns)
(ns mikera.vectorz.matrix_api)
(+ M1 M2)
(core.matrix/+ M1 M2)
(ns mikera.vectorz.core)
(add m1 m2)
(add M1 M2)
(add (vector 5 6 7 8) (vector 1 2 3 4))
M1
(def M1 (mikera.matrixx.Matrix/create (clojure.core/to-array m1) ))
(def m1 [[1 2 3 4]
[0 0 10 0]
[3 0 5 6]])
(def M1 (mikera.matrixx.Matrix/create (clojure.core/to-array m1) ))
m1
M1
(def M2 M1)
(mikera.matrixx.algo.Multiplications/multiply M1 M2)
(mikera.matrixx.algo.Multiplications/multiply M1 (.transpose M2))
(mikera.matrixx.algo.Multiplications/multiply M1 (.getTranspose M2))
m1
M1
(. System exit 0)
(ns 'mikera.vectorz.matrixx)
(ns mikera.vectorz.matrixx)
(identity-matrix 3)
(vec4)
(new-matrix 2 3 )
(ns mikera.vectorz.matrix)
(new-matrix 2 3 )
(ns 'mikera.vectorz.matrix)
(ns mikera.vectorz.matrix)
(identity-matrix 3)
(dir mikera.vectorz.matrix)
(. System exit 0)
(def {:keys [Q R]} [1 2])
(defn f [x] ())
(defn f [x] ([x (inc x)]))
(let [{a b} (f 3)] ([a b]))
(let [a 3] (a))
(def x {:keys [5 7]})
x
(x 1)
(:keys x)
((:keys x) 0)
(defn f [input]
(let [{:keys [q r]}]
[3 4]))
x
(keys x)
(defn f [input]
(let [{:keys [q r]}]
{3 [4 5]}))
(defn f [input]
(let [{:keys [q r]}]
{:a [4 5]}))
(defn f [input]
(let [{:keys [q r]} {:a [4 5]}]
[q r]))
(f 10)
(defn f [input]
(let [{:keys [q r]} {:a [4 5]}]
:a))
(f 10)
(def a {:b :c})
a
(:b a)
(a :b)
(keys a)
(a :c)
(:c a)
(. System exit 0)
(def h {})
h
((h :a 1))
(count h)
(def h {:a 1 :b 2})
(count h)
(h 1)
(def options {:keys [Q R]})
(def options {:keys [:Q :R]})
(nil? options)
(count options)
(count (options :keys))
(nil? (options :keys))
(def options {:keys nil})
(nil? (options :keys))
(def options {:keys []})
(empty? (options :keys))
(== 3 4)
(== 3 3)
(def options nil)
(options :keys)
h
(def options {:keys [:Q :R]})
(def keys (options :keys))
keys
(contains? keys :Q)
(def l (options :keys))
(contains? l :Q)
(contains? l ':Q)
(contains? l :Q)
(in? l :Q)
(some :Q l)
(some #{:Q} l)
(nil? (some #{:Q} l))
(nil? (some #{:Stored} l))
(def l [:A :B :R :C :Q :D])
(vector? l)
(list? l)
(filter (fn [x] (or (== x :Q) (or (== x R)))) l)
(filter (fn [x] (or (== x :Q) (or (== x :R)))) l)
(== :r :r)
(equal? :r :r)
(filter (fn [x] (or (= x :Q) (or (= x :R)))) l)
(def l [:A :B :R :C :Q :D :D])
(filter (fn [x] (or (= x :Q) (or (= x :R)))) l)
(def l [:A :B :R :C :Q :D :D :R])
(filter (fn [x] (or (= x :Q) (or (= x :R)))) l)
(distinct l)
(l 0)
(l 1)
(def options nil)
(nil? options)
(defn p [a b])
(defn p [a b]
(cond
(nil? b) [a a]
else: [a]))
(defn p [a b]
(cond
(nil? b) [a a]
:else [a]))
(p :a :b)
(p :a nil)
(def ks [1 2 3])
(ks 0)
(count ks)
(vector? [])
(def t {:return []})
(t :return)
(def t {:return [:a :b :Q :c :Q :c :R]})
(filter (fn [x] (or (= x :Q) (= x :R))) (distinct (t :return)))
(def ks (filter (fn [x] (or (= x :Q) (= x :R))) (distinct (options :return))))
(def ks (filter (fn [x] (or (= x :Q) (= x :R))) (distinct (t :return))))
ks
(cond
                    (== 0 (count ks)) "{:Q [1 2]}"
                    (== 2 (count ks)) "{:Q (.getQ result) :R (.getR result)}"
                    :else (cond
                            (= :Q (ks 0)) "{:Q (.getQ result)}"
                            :else         "{:R (.getR result)}))"
(+ 2 3)
""
;
exit
(. System exit 0)
(conj 1 2 3)
(conj (1 2 3) 4)
(conj [1 2 3] 4)
(conj '(1 2 3) 4)
(def a [:a :a :b :c :b :d])
(distinct a)
(list? (distinct a))
(seq? (distinct a))
(coll? (distinct a))
(some #{:a} a)
(some #{:b} a)
(some #{:d} a)
(some #{:e} a)
(true? (some #{:e} a))
(true? (some #{:d} a))
(true? (some #{:core} a))
(true? (some #{:c} a))
(filter (fn [x] (some #{x} [:a :d]) a))
(filter (fn [x] (some #{x} [:a :d])) a)
(filter (fn [x] (some x [:a :d])) a)
(filter (fn [x] (some #{x} [:a :d])) a)
(filter (fn [x] (some #{x} [:a :d])) (distinct a))
(filter (fn [x] (some #{x} [:a :f])) (distinct a))
(def available [:Q :R])
(def available [:Q :R :S])
(def valid [:Q :R])
(apply hash-map valid)
(:Q (apply hash-map valid))
(into {} (map vector [:Q :R] [1 2]))
(into {} (map vector [:Q :R] [1 2 3]))
(str :R)
:R
(name :R)
(map (fn [x] `(str "(.get" ~(name x " result"))))
(map (fn [x] `(str "(.get" ~(name x " result")) valid))
(map (fn [x] `(str "(.get" ~(name x " result"))) valid)
(map (fn [x] `(str "(.get" ~(name x) " result")) valid)
(map (fn [x] `(~str "(.get" ~(name x) " result")) valid)
(map (fn [x] `(str "(.get" ~(name x) " result")) valid)
(map (fn [x] (str "(.get" ~(name x) " result")) valid)
(map (fn [x] (str "(.get" (name x) " result")) valid)
(map (fn [x] (str "(.get" (name x) " result)")) valid)
(def calls (map (fn [x] (str "(.get" (name x) " result)")) valid))
valid
(into {} (map vector valid calls))
(map (fn [x] (str "(.get" (name x) " result)")) valid)
(map (fn [x] (read-form (str "(.get" (name x) " result)"))) valid)
(map (fn [x] (read-read-string (str "(.get" (name x) " result)"))) valid)
(map (fn [x] (read-string (str "(.get" (name x) " result)"))) valid)
(def calls (map (fn [x] (read-string (str "(.get" (name x) " result)"))) valid))
calls
(into {} (map vector valid calls))
(defmacro with-keys
  [available chosen]
  (let [valid (filter (fn [x] (some #{x} available)) (distinct chosen))
        calls (map (fn [x] (read-string (str "(.get" (name x) " result)"))) valid)]
    (into {} (map vector valid calls))))
(with-keys [:a :b :c] [:a :c])
(defmacro with-keys
  [available chosen]
  (let [valid (filter (fn [x] (some #{x} available)) (distinct chosen))
        calls (map (fn [x] (read-string (str "(.get" (name x) " result)"))) valid)]
    '(into {} (map vector valid calls))))
(with-keys [:a :b :c] [:a :c])
(def avilable [:a :b :c])
(def chosen [:a :c])
(with-keys available chosen)
(. System exit 0)
(defmacro with-keys [hm ks]
  (select-keys hm ks))
(defn tester
[m options]
(let [result (+ 9 4)]
(with-keys {:Q (+ 5 result) :R (+ 7 result)} [:Q])))
(tester 1 2)
(defmacro with-keys [hm ks]
  '(select-keys hm ks))
(defn tester
[m options]
(let [result (+ 9 4)]
(with-keys {:Q (+ 5 result) :R (+ 7 result)} [:Q])))
(defmacro with-keys [hm ks]
  (select-keys hm ks))
(defn tester
[m options]
(let [result (+ 9 4)]
(with-keys {:Q (+ 5 result) :R (+ 7 result)} [:Q])))
(tester 1 2)
(defmacro with-keys [hm ks]
  (select-keys hm ks))
(with-keys {:Q (+ 1 2) :R {+ 3 4}})
(with-keys {:Q (+ 1 2) :R (+ 3 4)} {:return [:Q]})
(with-keys {:Q (+ 1 2) :R (+ 3 4)} [:Q])
(macroexpand '(with-keys {:Q (+ 1 2) :R (+ 3 4)} [:Q]))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} [:Q]))
(def options (:return [:Q]))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} [:Q]))
(defmacro with-keys [hm ks]
  (select-keys hm ~ks))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
(def os (:return options))
os
options
(def options {:return [:Q]})
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
(defmacro with-keys [hm ks]
  (select-keys hm ks))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
(def os (:return options))
os
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} os))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
options
(defmacro with-keys [hm ks]
  (let [os (:return ks)] (select-keys hm os)))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} options))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} {:return [:Q]}))
(def options {:return [:Q]})
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
(defmacro with-keys [hm ks]
  (select-keys hm (eval ks)))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
options
(defmacro with-keys [hm ks]
  '(select-keys hm (eval ks)))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
(defmacro with-keys [hm ks]
  (select-keys hm (eval ks)))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
(defmacro with-keys [hm ks]
  (select-keys hm ~ks))
(macroexpand '(with-keys {:Q (.getQ result) :R (.getR result)} (:return options)))
(defmacro with-keys [hm ks]
  (select-keys hm ks#))
(defmacro with-keys [hm ks]
  (select-keys hm #ks))
(def options {:return [:Q]})
(defmacro with-keys
[hm ks]
(select-keys hm ks))
(macroexpand '(with-keys {:Q (+ 1 2) :R (+ 3 4)} (:return options)))
(macroexpand '(with-keys {:Q (+ 1 2) :R (+ 3 4)} (eval (:return options))))
(let [os (:return options)] (macroexpand '(with-keys {:Q (+ 1 2) :R (+ 3 4)} os)))
(defmacro open [xs]
`~xs)
(open (:return options))
(macroexpand '(open (:return options)))
(defmacro open [xs]
xs)
(macroexpand '(open (:return options)))
(defmacro open [xs]
'xs)
(macroexpand '(open (:return options)))
(defmacro open [xs]
(eval xs))
(macroexpand '(open (:return options)))
(cons nil (1))
(cons nil 1)
(cons nil)
(cons nil [2])
(identity 3)
(cons + 1 2)
(cons + (cons 1 2))
(cons 1 2)
(. System exit 0)
